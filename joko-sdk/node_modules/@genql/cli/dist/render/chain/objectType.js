"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectType = exports.chainTypeName = void 0;
const graphql_1 = require("graphql");
const comment_1 = require("../common/comment");
const renderTyping_1 = require("../common/renderTyping");
const toArgsString_1 = require("../common/toArgsString");
const requestTypeName_1 = require("../requestTypes/requestTypeName");
const config_1 = require("../../config");
const support_1 = require("../common/support");
const chainTypeName = (type, wrapper) => {
    return `${type.name}${wrapper}Chain`;
};
exports.chainTypeName = chainTypeName;
const objectType = (type, ctx, wrapper) => {
    var _a;
    // console.log(Object.keys(type.getFields()))
    const fieldsMap = ((_a = ctx.config) === null || _a === void 0 ? void 0 : _a.sortProperties) ? support_1.sortKeys(type.getFields())
        : type.getFields();
    const fieldStrings = Object.keys(fieldsMap).map((fieldName) => {
        const field = fieldsMap[fieldName];
        const resolvedType = graphql_1.getNamedType(field.type);
        // leaf type, obly has.get() method
        const stopChain = graphql_1.isListType(field.type) ||
            (graphql_1.isNonNullType(field.type) && graphql_1.isListType(field.type.ofType)) ||
            graphql_1.isUnionType(resolvedType);
        // non leaf type, has .get method
        const resolvable = !(graphql_1.isEnumType(resolvedType) || graphql_1.isScalarType(resolvedType));
        const argsPresent = field.args.length > 0;
        const argsOptional = !field.args.find((a) => graphql_1.isNonNullType(a.type));
        const argsString = toArgsString_1.toArgsString(field);
        const executeReturnType = renderTyping_1.renderTyping(field.type, true, false, false);
        const executeReturnTypeWithTypeMap = renderTyping_1.renderTyping(field.type, true, false, false, (x) => `FieldsSelection<${x}, R>`);
        //     get: <R extends RepositoryRequest>(
        //         request: R,
        //         defaultValue?: Repository,
        //     ) => Promise<FieldsSelection<Repository, R>>
        // }
        const getFnType = `{get: <R extends ${requestTypeName_1.requestTypeName(resolvedType)}>(request: R, defaultValue?: ${executeReturnTypeWithTypeMap}) => ${wrapper}<${executeReturnTypeWithTypeMap}>}`;
        const fieldType = resolvable
            ? stopChain
                ? getFnType
                : `${exports.chainTypeName(resolvedType, wrapper)} & ${getFnType}`
            : `{get: (request?: boolean|number, defaultValue?: ${executeReturnType}) => ${wrapper}<${executeReturnType}>}`;
        const result = [];
        if (argsPresent) {
            result.push(`((args${argsOptional ? '?' : ''}: ${argsString}) => ${fieldType})`);
        }
        if (!argsPresent || argsOptional) {
            result.push(`(${fieldType})`);
        }
        return `${comment_1.fieldComment(field)}${field.name}: ${result.join('&')}`;
    });
    ctx.addImport(config_1.RUNTIME_LIB_NAME, false, 'FieldsSelection', true, true);
    if (wrapper === 'Observable') {
        ctx.addImport(config_1.RUNTIME_LIB_NAME, false, 'Observable', true, true);
    }
    ctx.addCodeBlock(`${comment_1.typeComment(type)}export interface ${exports.chainTypeName(type, wrapper)}{\n    ${fieldStrings.join(',\n    ')}\n}`);
};
exports.objectType = objectType;
//# sourceMappingURL=objectType.js.map